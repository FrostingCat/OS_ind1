# Зайцева Юлия Александровна, БПИ213

# Домашнее задание №1
Использование каналов.

## Вариант задания 20: 
Разработать программу, вычисляющую число вхождений различных цифр в заданной ASCII-строке.

## Реализация программы на 4
1. **Общая схема решаемой задачи:** 

a. Были созданы три дочерних процесса: readf - для открытия файла input.txt, count - для подсчета кол-ва цифр, out - для вывода результатов в файл output.txt. В родительских процессах происходило создание дочерних, а в дочерних - вся основная логика программы;

b. Для передачи информации между процессами использовалась разделяемая память. В share хранился считываемые символы из файла, в share_i - кол-во символов, в numbers - кол-во различных цифр;

c. Для задания имен входного и выходного файлов используются аргументы командной строки;

d. Ввод и вывод данных при работе с файлами осуществляется через системные вызовы read и write.

e. 5 тестовых файлов и 5 файлов результатов представлены;

2. **В ассемблерном коде было реализовано:** 

a. Добавлены комментарии, поясняющие эквивалентное представление переменных в программе на C. Также комментарии описывают передачу фактических параметров и перенос возвращаемого результата из функции. Также добавленные комментарии описывают связь между параметрами языка Си и регистрами;

b. Убраны лишние макросы;

c. Был произведен рефакторинг за счет максимального использования регистров процессора;

d. Функции были вынесены в отдельный файл func - 3.s, а main находится в файле main - 3.s;

3. **Использованные опции компиляции:** 

a. **Компиляция напрямую из Си кода в машинный:** gcc -O0 -Wall -fno-asynchronous-unwind-tables main.c -o c

b. **Получение ассемблерного кода:** gcc -O0 -Wall -fno-asynchronous-unwind-tables -S main.c -o assemble.s

c. **Получение исполняемого файла:** gcc assemble.s -o assemble

4. **Тестовое покрытие:** 

Результат в программе на Си:

1. При работе с файлами:

Ввод

![ФАйл](https://user-images.githubusercontent.com/97798186/202863901-823e080a-692f-400f-b662-b36f0ca0b2ab.jpg)

Вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/202863929-282cbf11-54e0-4afa-8af9-71674705f00c.jpg)

2. При генерации данных:

Сгенерированы a и b, границы интегрирования

![ФАйл](https://user-images.githubusercontent.com/97798186/202864476-c3a50a1c-da93-48de-a986-98823ffc9b3f.jpg)

Результат в программе на Ассемблере:

1. При работе с файлами:

Ввод - аналогичный файл, как в программе на Си

![ФАйл](https://user-images.githubusercontent.com/97798186/202863901-823e080a-692f-400f-b662-b36f0ca0b2ab.jpg)

И аналогичный вывод

![ФАйл](https://user-images.githubusercontent.com/97798186/202863929-282cbf11-54e0-4afa-8af9-71674705f00c.jpg)

2. При генерации данных:

Сгенерированы a и b, границы интегрирования

![ФАйл](https://user-images.githubusercontent.com/97798186/202864532-7308f680-86d6-4cad-9e42-5ff4495f04e8.jpg)

5. **Сравнение на производительность:** 

a. Для сравнения был использован файл, в котором a = 10, b = 20, нижний предел = 2, верхний предел = 13. Была использована функция clock().

Сначала была протестирована программа на Си. Ее результат:

![ФАйл](https://user-images.githubusercontent.com/97798186/202865151-d22e6ee0-d02a-4d4e-acf9-6c3b54b9ce53.jpg)

Затем протестировали программу на ассемблере:

![ФАйл](https://user-images.githubusercontent.com/97798186/202905503-3c61cf60-9e5e-4024-bb99-2baa5ef99ae5.jpg)

Вывод: программа на ассемблере с рефакторингом работает в 5 раз дольше программы на Си.

6. **Сравнение по ассемблерных программ с опциями оптимизации:** 

a. Использование опций оптимизаций по скорости. Были использованы следующие оптимизации: -O3 и -pipe (файл "assemble скорость.s")

b. Использование опций оптимизаций по размеру. Были использованы такие оптимизации: -Os, -fomit-frame-pointer (файл "assemble размер.s")

c. Также были изучены другие опции: -O1, O2, Ofast.

Результаты тестирований (без учета времени ввода и вывода данных) представлены в таблице:

![ФАйл](https://user-images.githubusercontent.com/97798186/202906666-c67c15ac-8aaa-4b5f-aaba-ecb51a18f040.jpg)

Программа без рефакторингом и с рефакторингом работают дольше всего, причем у программы с рефакторингом производительность самая низкая. Программа с оптимизациями по скорости оказалась не самой быстрой: самой производительно оказалась программа с опцией -О1. Как и ожидалось, программа с оптимизациями по размеру имеет самый небольшой объем ассемлерного кода.


